# AI Modeling Pipeline for Verifiable Drug Screening

## 1. Overview

The heart of the verifiable virtual drug screening platform is its AI-powered modeling pipeline. This pipeline is responsible for performing the core scientific analysis: predicting the efficacy and safety of potential drug molecules using computational models. This process, known as virtual screening, allows for the rapid evaluation of thousands of compounds, saving significant time and resources compared to traditional, lab-based methods.

The entire AI pipeline is encapsulated within `modeling/molecular_modeling.py`.

## 2. Core Components

The pipeline consists of three main components:

- **Molecular Feature Extraction**: Converts a chemical structure into a numerical format that AI models can understand.
- **Prediction Models**: A set of AI models that predict key properties of the molecule.
- **Screening Pipeline**: An orchestrator that manages the end-to-end screening process for a given molecule.

### 2.1. Molecular Feature Extraction with RDKit

Before any predictions can be made, a molecule's structure (typically represented as a SMILES string) must be converted into a set of quantitative descriptors, or "features." We use the open-source cheminformatics library `RDKit` for this critical step.

The `get_molecular_features` function calculates a variety of properties, such as:

- **Molecular Weight**: The mass of the molecule.
- **LogP**: A measure of the molecule's hydrophobicity.
- **Topological Polar Surface Area (TPSA)**: An indicator of a drug's ability to permeate cell membranes.
- **Lipinski's Rule of Five**: A set of rules of thumb to evaluate if a chemical compound has properties that would make it a likely orally active drug in humans.

These features provide the foundation for the predictions made by the AI models.

### 2.2. Prediction Models

We employ two primary AI models to assess a molecule's potential:

#### `BindingAffinityModel`
- **Purpose**: To predict how strongly a molecule will bind to a specific biological target (e.g., a protein implicated in a disease).
- **Mechanism**: In a real-world scenario, this would be a sophisticated machine learning model (e.g., a graph neural network or a random forest) trained on experimental binding data. In our current implementation, it uses a pre-defined dictionary of known binding affinities for common molecules (`aspirin`, `ibuprofen`, etc.) and simulates a plausible value for unknown molecules.
- **Output**: A numerical score in kcal/mol, where a more negative value indicates stronger binding.

#### `ToxicityModel`
- **Purpose**: To predict the potential toxicity of a molecule to the human body.
- **Mechanism**: Similar to the binding model, this would typically be a complex model trained on toxicological data. Our implementation uses a lookup for known molecules and simulates a toxicity score for unknown ones.
- **Output**: A score between 0 and 1, where a higher value indicates greater potential toxicity.

### 2.3. The `ScreeningPipeline`

The `ScreeningPipeline` class is the master orchestrator. It brings all the components together to perform a complete screening job.

Its `run` method executes the following steps:

1.  **Receives a Molecule**: Takes a molecule's ID and SMILES string as input.
2.  **Generates Features**: Calls `get_molecular_features` to get the RDKit-derived properties.
3.  **Runs Prediction Models**: Passes the features to the `BindingAffinityModel` and `ToxicityModel` to get predictions.
4.  **Generates a Comprehensive Result**: Compiles all the information—input data, features, and predictions—into a single, structured dictionary.
5.  **Provides an Assessment**: Based on the binding and toxicity scores, it provides a high-level assessment, such as "PROMISING," "MODERATE," or "POOR."

## 3. Connection to the Blockchain

The final, structured result generated by the `ScreeningPipeline` is the scientific record that gets secured on the blockchain.

The `workflow/verification_workflow.py` script takes this result, calculates its unique hash (a digital fingerprint), and calls the `recordScreeningResult` function on the smart contract. This creates an immutable, timestamped, and verifiable proof of the screening outcome, fulfilling the core mission of the project.
